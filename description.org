
* Setting up

** Stuff to install Using opam, install
    + oasis
    + batteries
    + ppx_deriving.show
    + ppx_deriving.yojson

    Also requires OCaml, python3 with python3-graphviz and python3
** Usefull stuff
   ocaml tools (Installed with opam) :
    + merlin (completion and errors detection in emacs)
    + utop (advanced top-level)

   emacs tools (installed with melpa) : 
    + outshine / outorg
    + tuareg-mode
    + graphviz-dot mode
      
* Intro

  Du coup, on veut ici créer un programme qui réalise le rêve de
  la vie artificielle :
  héberger et simuler des cellules qui vont évoluer afin de recréer
  la vie /in silico/ (on peut toujours rêver).

** Résumé des épisodes précédents

   Il y a eu plusieurs essais dans ce sens : 
     - Tierra : 
        + Le monde est un tableau unidimensionnel. Chaque case est soit
          vide, soit contient une instruction, parmi un jeu 
          d'instruction bien choisi.
 
        + Les cellules sont un ensemble contigu de cases, et donc des
	  instructions qu'elles contiennent.

       Le jeu d'instruction permet aux cellules de lire n'importe où, 
       mais pas d'écrire à l'intérieur d'autres cellules. Les cellules 
       se dupliquent en recopiant leur code génétique vers une partie 
       vide de la bande.

        + Chaque cellule a son processeur propre, qui simule
          l'exécution de son code.

        + Comportements apparus : spécialisation, parasitage, un peu de 
          complexification

     - Des trucs d'Hutton : 
        + Le monde est un tableau bidimensionnel. Le monde contient
          des atomes, qui peuvent se déplacer plus ou moins librement.
        
        + Les atomes ont un type donné, et un état qui peut varier au 
          cours du temps. Un jeu de réactions chimique, qui détermine 
          si deux atomes de type et d'état donné qui se rencontrent 
          vont former une liaison. 
          Jeu de réactions chimiques bien choisi.

        + Les cellules ont une membrane qui forme un cercle, et un brin 
          d'ADN, relié à ses deux extrémités à la membrane. Les 
          cellules se dupliquent de manière spontanée grâce aux 
          réactions chimiques. 

        + Le monde est simulé /physiquement/, c'est à dire chaque atome 
          séparemment, et rien d'autre.

        + Comportements apparus : pas grand chose, à part une légère 
          réduction de l'ADN.

     En résumé, Tierra s'est montré prometteur, mais est beaucoup plus 
     proche d'un ordinateur que d'une cellule. On manque en particulier 
     de capacité de réaction, de communication, etc...

     Hutton est très proche en quelques sorte de la biologie, mais 
     ça ne marche pas très bien. Sans parler des coûts de simulation 
     faramineux, ni du jeu de réactions chimiques tellement alambiqué 
     pour que ça marche que c'en est un peu absurde. 


** Où l'on essaie de préparer un autre épisode

   Ce que j'aimerait faire, c'est un modèle qui soit à la fois proche
   du fonctionnement des ordinateurs (c'est à dire en particulier avec 
   une physique très simple, sans avoir besoin de simuler des choses à 
   un niveau très bas), et qui reflète le principe de fonctionnement 
   d'une cellule autant qu'il est souhaitable et possible.

   Une première idée à été de faire un peu comme Tierra, mais en plus 
   de dimensions. Une cellule est une matrice, où les fonctions sont
   des instructions qui pointent vers la suivante (contiguë). En trois
   dimensions, ça peut commencer à donner des trucs assez rigolos, 
   mais gérer la duplication semble devenir complexe. On perds aussi 
   la bonne relation qui existait entre les cellules et l'univers.
 
   La deuxième idée est d'utiliser des modèles complutationnels simples 
   pour simuler les protéines. Partant des automates, j'en suis arrivé 
   aux réseaux de Petri, qui me semblent assez prometteurs. 
   On le décrira plus précisement par la suite.
   
** Trucs importants à garder en tête

   Les membranes, c'est la vie en plus tranquille.
   La communication, c'est la vie en plus rigolo.
   La vie tout court, c'est déjà pas mal.
   Les ribosomes, c'est trop l'éclate.
   Toute action engendre une réaction.

* Description de ce que j'essaie de faire

** But

   Le but est d'avoir un modèle unifié de molécules, qui permettent à 
   la fois d'avoir des molécules qui :
     - représentent de l'information (ADN)
     - puissent agir sur d'autres molécules (protéines, enzymes), et 
       plus précisement 
        + Découper une molécule
        + Insérer une molécule dans une autre
        + Lire de l'information écrite sur une molécule
     - puissent échanger de l'information (métabolites)
   
   Enfin en vrai le but c'est de faire des *RIBOSOMES*, 
   ne l'oublions pas.
   
** Mise en œuvre
  
   Le modèle proposé est d'avoir tout d'abord des protéines sous forme
   de liste d'acides (aminés), chaque acide contenant soit de
   l'information, soit un morceau qui permette de reconstituer les
   fonctionnement de la protéine : 
   on veut la *replier* pour obtenir un réseau de pétri (plutôt un peu étendu).
   
   Un des trucs cool, c'est qu'on peut faire des *ribosomes* ! Et donc 
   permettre à la duplication elle même d'évoluer.   

*** Modèle pour les protéines et la formation du réseau de pétri
    
    Une protéine est donc formée par une liste d'acide, dont le rôle va 
    être de
     + former des place du réseau de Pétri, 
     + contribuer à former des transitions du réseau
     + contenir de l'information
       
     Après une opération de repli, on pourra attribuer à une protéine 
     un réseau de pétri (graphe biparti). Il y a plusieurs moyens 
     d'organiser une protéine et la façon dont elle se 
     replie, on va donc détailler et justifier un peu le processus.
    
**** Différentes idées 
     
     Tous les acides de la protéine forment une place, et se retrouvent 
     donc au même niveau. Des places particulières contiennent un arc 
     entrant ou un arc sortant. Plusieurs inconvénients : 
       - Ça limite fortement les fonctionnalités d'une protéine
       - Un seul arc entrant ou sortant par place
   
       Du coup, il faut pouvoir ajouter des attributs à une place. Ou 
       pourrait faire ça de manière interne, mais on précisera dans la 
       partie suivante pourquoi on choisira ici une mméthode externe.

**** Modèle retenu
     
     On fonctionnera de manière modulaire, avec les types d'acide 
     suivants :
      + place : correspond à une place du réseau de pétri. On pourra 
      fournir un attribut interne pour effectuer certaines actions
      + transition_input/output : ajoute un arc sortant/entrant  
      + extension : ajoute un attribut à la place précédente dans la 
        molécule. 
        Quelques types d'extension : 
         - information : un morceau d'information
         - autre ? action ?
     
      Les avantages sont les suivants : 
       + facile à étendre
       + du point de vue des mutations possibles, on a facilement des 
         changements de fonctionnalité

*************** TODO Un *GROS PROBLÈME*:

       Que se passe-t-il si plusieurs transtions input avec la même id 
       partent d'un même nœud, en particulier 
       pour la gestion des token ?
       Plusieurs pistes :
        - la transition n'est pas crée
        - seul un des arcs est pris en compte
        - utiliser un des arcs au hasard
        - le programme bugge

**** Détails d'implémentation

On part donc d'une protéine = liste d'acides.
On parcourt la protéine pour en extraire :
    1. d'une part la liste des nœuds, en associant à chaque nœud la 
       liste des extensions qui le suivent
    2. d'autre part tous les arcs sont stoqués dans une liste (qui 
       pourrait être remplacée par un dictionnaire) dans laquelle on 
       stoque pour chaque id de transition les transitions 
       correspondantes

       
***** Questions

Est-ce qu'on définit un unique type extension (qui contient les transitions) ou on sépare les transitions ?
À priori c'est pas mal de séparer puisque :
 + les transitions font partie de la structure du réseau de pétri, au contraire des autres extensions
 + ça permet de construire le réseau sans avoir à connaitre l'implémentation particulière des types

**** Arguments pour le réseau de pétri

Les réseaux de pétri forment donc le modèle de calcul utilisé par
les bactéries pour fonctionner, interagir et se dupliquer.

Nous allons ici développer quelques arguments pour soutenir 
ce choix.
 
 + Le réseau de pétri est formé de manière non linéaire à partir d'une 
   liste d'acides. Cela devrait le rendre peu vulnérable à des 
   modifications mineurs de la liste d'acides formant la protéine.

   Reste cependant le fait que les protéines sont formées à partir 
   d'une liste d'atomes, qui est elle sensible à des variations locales.

 + Du fait de sa forme de graphe, le réseau de pétri peut être associé
   à une certaine spatialité. Par exemple, une protéine connectée à
   la membrane peut avoir une partie à l'intérieur, et une autre partie
   à l'extérieur de la membrane.

 + On peut sans trop de difficultés connecter des réseaux de pétri 
   entre eux (bind/catch), permettant d'étendre leur fonctionnalités,
   ainsi que de créer des *membranes*.

*** Modèle pour le réseau de pétri

    Un réseau de Pétri est un graphe bipartie  (deux types de nœuds) :
     - des places, qui correspondent directement à un acide de la 
       protéine
     - des transitions, qui sont construites implicitements à partir 
       d'arcs entrants et sortants, décrits dans la protéine

    Les places contiennent des token, qui peuvent eux-même contenir une 
    molécule (et de l'information, et autre ?).
    Une transition peut être lancée quand toutes les places de départ 
    de la transition contiennent un token, et qu'il n'y a pas de token 
    dans les places d'arrivée.

    Les protéines doivent gérer :
     1. Le réseau de pétri, c'est à dire le déclenchement de 
     transitions et la gestion des tokens qui va avec
     2. Tous les effets appliqués sur le tokens par les transitions et 
     les extensions
     3. L'interface avec la bactérie, c'est à dire l'envoi/reception de 
     message, et l'attachement/détachement de molécules
	
***** Réseau de pétri
      
****** Token et MoleculeManager
       Un token est soit vide, soit contient un moleculeHolder, qui est 
       lui-même une interface contenant une molécule et un poiteur 
       (entier) vers un des acides de la molécule, et qui permet de 
       manipuler celle-ci : 
        - découpage (à la position du pointeur)
	- insertion d'une autre molécule (à la position du pointeur)
	- déplacement du pointeur

	On va aussi ajouter un possible label à un token, qui permettra
	aux arcs de filtrer les token.
****** Places
       Les places sont soit vides, soit contiennent un token. Elles 
       gardent aussi en mémoire la liste des extensions associées, et 
       implémentent une interface pour gérer l'éventuel token.

*************** TODO Ajouter les effets sur les tokens générés par les extensions ?       

****** Transitions

       Les transitions ont pour l'instant pour rôle de découper et 
       recoller des molécules. Voilà comment ça se passe :
 
        1. Quand un token porteur passe par un arc entrant, 
	   - si le token porte une molécule et que l'arc est de 
	   type Split, la molécule est coupée en deux, chaque partie 
	   est stoquée dans un token
	   - sinon, le token (avec l'éventuelle molécule) n'est pas 
	   modifié

	2. Tous les token venant des arcs entrant sont mis dans un « 
	pool » commun

	3. Les token passent dans les transitions sortantes, dans un 
	ordre fixe déterminé par les transitions d'arrivée : 
	   - Si deux token porteur de molécule se trouvent devant un 
	   arc de type Bind, la seconde molécule est insérée dans la 
	   première
	   - Sinon, un unique token passe par l'arc sortant
	   - Si il reste des token, ils sont perdus
	   - Si il n'y a pas assez de token, les places d'arrivée ne 
	   sont pas remplies
	     
	On remarquera vite que tout ça n'a pas l'air très propre, mais 
	en même temps on traite ici avec le « vivant », donc c'est un 
	peu normal :)
	Plus sérieusement, on supposera pour l'instant que les capacités
	évolutives des bactéries ne seront pas affectées. 
	
*************** DONE Implémenter proprement ce modèle dans les transitions 


	Une transition peut affecter les token, mais aussi l'environnement
	(c'est à dire la bactérie), par exemple en relachant une molécule.
	
	Comme c'est la bactérie qui a l'initiative pour lancer une transition,
	on donne un type de retour aux transition qui permettra de passer 
	l'information nécéssaire.
	
*** Modèle pour une bactérie
    
    Une bactérie est simplement une boite contenant des protéines,
    dont il faut organiser le déroulement des interactions.
    
    Il y a principalement trois choses à gérer : 
     + une protéine en attrape une autre
     + les transitions du réseau de pétri d'une protéine 
     + l'échange de message (on verra plus tard)

**** Une protéine en attrape une autre


     Une molécule peut en attrapper une autre si elle a une place avec
     une extension « mol_catcher » correspondant à une « handle » sur
     une autre protéine.
 
     On peut donc garder en mémoire une table qui référence des couples
     de molécule (catcher, handle), indexés par un identifier.

     Il faut ensuite déterminer si deux protéines d'un de ces couples 
     interagissent, en fonction du nombre présent de chacune d'elles.

     On pourrait faire en sorte qu'avoir plusieurs catcher/handle du
     avec le même id augmente les chances d'interaction, mais ce n'est
     pas le facteur principal pour de vraies réactions chimiques, et ça
     compliquerait un peu le modèle.

     Donc dans le cas où on aurait plusieurs catcher/handle, on peut 
     simplement en choisir un aléatoirement.

*************** TODO Que se passe-t-il si une protéine réagit avec elle même ? 

*************** TODO Ce mode de réaction est trop déséquilibré.
		Une petite molécule peut attrapper et donc détruire ou
		désactiver trop facilement d'autres molécules.
		Autre idées : 
		 + Deux molécules réagissent en formant un réseau de pétri 
		 élargi.
		Enfin c'est compliqué, mais à creuser
*************** TODO Il faudrait aussi permettre d'attrapper une molécule 
		par les acides (ou plutôt ce qui la compose au niveau inférieur;
		non encore implémenté).
		Ça permettrait au moins d'attrapper les composants de base
		(ce que le ribosome ne peut pas faire pour l'instant,
		puisque pour attrapper qqchose il faut une poignée : pas très 
		pratique).


		 
**** Gestion des transitions des réseaux de pétri

     On peut organiser la répartition du temps de calcul (= nb de transitions
     lancées) entre les protéines de diverses manières

***** Rapide, un peu grossier
      Chaque molécule présente possède un unique représentant sous forme protéinée.
      
      Le nombre de molécules présente détermine la vitesse de réaction.

      Si une molécule est attrapée par une autre, on peut considérer qu'il y en a 
      une de moins dans la bactérie, jusqu'au moment où elle est relachée.

** Processus de reflexion sur comment faire avancer le schmilblick en cours

*** Atomes et molécules

    Les atomes sont les briques de base pour construire des molécules.
    Il y a pour l'instant quatre types d'atomes, dont les séquences 
    dans une molécule sont interprétées pour former les acides des
    protéines.

**** Utilisation actuelle

     Pour l'instant, on lit une séquence d'atomes par groupes de 3.
     Quand une séquence formant un acide est reconnue, on ajoute cet 
     acide à la protéine, et on passe à la séquence de trois atomes 
     suivants.

     Si la séquence n'est pas reconnue, on décalle d'un atome 
     (l'atome en plus est donc ignoré dans la formation de la protéine).

***** Informations supplémentaires

     Certains acides ont besoin d'information supplémentaire, qui est 
     lue dans la suite d'atomes, jusqu'à atteindre une séquence d'arrêt 
     (pour l'instant trois atomes D à la suite).

     Ce type de séquence est aussi utilisé pour générer les 
     expressions régulières des grabers, il faut donc avoir un 
     système cohérent.
     
*** Interactions entre proteines

    Les protéines sont sensés pouvoir interagir entre elles, notemment
    en s'attrappant les une les autres. 
    Le modèle de départ suppose qu'on peut attrapper une protéine dès
    lors qu'une des places contient une extension « Handle » (avec une 
    certaine clé)
    
    Problème : comment attrapper un simple acide ?
    (oui c'est très problèmatique si on veut fabriquer de nouvelles 
    molécules)

    Pour résoudre ça, on crée un niveau en dessous : une molécule est 
    une liste d'atomes, qui vont être interprétés en acides puis en 
    protéines.

    Une protéine pourra alors disposer d'un site qui attrappe une 
    molécule, en la reconnaissant avec une expression régulière.

**** Conséquences de ce modèle
     Un problème est que cela ajoute un niveau d'interprétation dans 
     l'édifice, mais ce niveau peut paraître naturel quand on veut 
     fabriquer des acides :
     l'avantage est que cela permet de limiter le nb de briques
     de base (atomes), ce serait un peu bizarre d'avoir tous les types
     d'acides qui se baladent dans la nature (sans parler de tous 
     les identifiants dont on a besoin).
     
     Reste à savoir comment organiser pratiquement tout ça pour que ça 
     reste cohérent, pratique et joli.
     

***** Molécule linéaire

      Le modèle le plus simple pour une molécule est simplement d'avoir
      une molécule linéaire (une liste).
      Des suites d'atomes sont alors interprétées directement comme 
      des acides, les atomes suivants pouvant donner de l'information 
      supplémentaire, etc.

      Mais le problème, 
      
***** Molécule sous forme de graphe
      
     Ce qui serait joli, ce serait d'avoir des connecteurs (à deux ou 
     trois branches), et des morceaux d'information, mais plus 
     compliqué à manipuler; il pourrait être intéressant de comparer 
     avec une structure linéaire pour les molécules.

**** Un autre type de réaction

     On peut garder un système de poignées et de sites qui attrappent 
     des poignées, mais avec un autre effet: au lieu d'avoir une 
     protéine qui capture et une molécule capturée, les deux protéines 
     seront « liées », en joignant par exemple les deux réseaux de 
     pétri.

*** Membrane

    La membrane est une partie essentielle d'une bactérie, puisqu'elle 
    la définit en établissant une barrière avec le monde extérieur.

    Pour l'implémentation d'une membrane, les fonctionnalités désirées 
    sont :
     + Permettre à la bactérie de réguler les entrées/sorties de 
     molécules
     + Établir une barrière /difficile/ à franchir pour les molécules
       extérieures non désirées.
     + Avoir un taille nécéssaire en fonction de la quantité de 
     molécules présentes, sous risque d'effets néfastes.
    
    Idée : Implémenter dans les cellules deux bornes qui doivent 
    être reliées par un certain nombre de protéines.
    (il faut que les protéines puissent se lier entre elles avec 
    des catch/bind)

*** Fonctionnement des proteines : des réseaux de pétri
*** Ribosome

    Un ribosome est une protéine qui lit un code génétique (ADN) et 
    construit des protéines en fonction de l'information contenue dans 
    l'ADN.

    Donc pour implémenter un ribosome, il faut être capable de lire de
    l'information contenue dans une molécule, de l'interpréter pour 
    recoller les bons acides au bon endroit sur une molécule en train
    d'être construite.

***** Implémentation possible d'un ribosome : 
    La molécule en train d'être construite se trouve à mol_start_place, 
    et le brin d'ADN lu se trouve à DNA_start_place.
    
    Les arcs entrants de transition qui partent de DNA_start_place sont 
    filtrants (fonctionnalité qui reste à implémenter), donc seule une 
    des filter_transition_i peut être lancéé (celle qui correspond à 
    l'information lue sur le brin d'ADN). 
    
    Lorsqu'une de ces transitions est lancée, la molécule se retrouve à 
    mol_temp_place_i, d'où elle va être lancée vers bind_transition_i, 
    qui lui accolera l'acide correspondant, et enfin rejoindre 
    mol_end_place (commun à tous les chemins).

    Il suffit ensuite de faire revenir la molécule et l'ADN à leur 
    place de départ (en ayant fait bouger la tête de lecture sur l'ADN) 
    pour recommencer l'opération avec le morceau d'information suivant.

    Voir le résultat du code suivant pour le graphe du réseau de pétri
    décrit, où les chemins que peut suivre la molécule sont en rouge, 
    les chemins que peut suivre le brin d'ADN est en bleu, et les acides
    en vert.
    
    #+BEGIN_SRC dot :file ribosome.png :cmdline -Kdot -Tpng
  digraph G {
          mol_start_place[color = "red"]
          DNA_start_place[color = "blue"]
          
          filter_transition_0[shape = "rectangle"]
          mol_temp_place_0[color = "red"]
          bind_transition_0[shape = "rectangle"]
          
          filter_transition_1[shape = "rectangle"]
          mol_temp_place_1[color = "red"]
          bind_transition_1[shape = "rectangle"]

          
          filter_transition_n[shape = "rectangle", style = "dotted"]
          mol_temp_place_n[color = "red", style = "dotted"]
          bind_transition_n[shape = "rectangle", style = "dotted"]
          
          DNA_end_place[color = "blue"]
          mol_end_place[color = "red"]
          
          acid_holder_0[color = "green"]
          acid_holder_1[color = "green"]
          acid_holder_n[color = "green"]
          
          mol_start_place -> filter_transition_0 ->
          mol_temp_place_0  -> bind_transition_0 ->
          mol_end_place [color =red];

          mol_start_place -> filter_transition_1 ->
          mol_temp_place_1  -> bind_transition_1 ->
          mol_end_place [color = "red"];

          mol_start_place -> filter_transition_n ->
          mol_temp_place_n  -> bind_transition_n ->
          mol_end_place [style = "dotted", color = "red"];

          DNA_start_place -> filter_transition_0 -> DNA_end_place
          [color = "blue"];
          DNA_start_place -> filter_transition_1 -> DNA_end_place
          [color = "blue"];
          DNA_start_place -> filter_transition_n ->
          DNA_end_place [style = "dotted", color = "blue"];

          acid_holder_0 -> bind_transition_0 [color = "green"];
          acid_holder_1 -> bind_transition_1 [color = "green"];
          acid_holder_n -> bind_transition_n [color = "green", style = "dotted"];
          
  }
#+END_SRC
 
   #+RESULTS:
   [[file:ribosome.png]]

   En détaillant un chemin en particulier, voici ce que cela donne : 
 

    #+BEGIN_SRC dot :file ribosome_detailed.png :cmdline -Kdot -Tpng
      digraph G {
              mol_start_place[color = "red"]
              DNA_start_place[color = "blue"]
              
              filter_transition[shape = "rectangle"]
              mol_temp_place[color = "red"]
              bind_transition[shape = "rectangle"]
              
              DNA_end_place[color = "blue"]
              mol_end_place[color = "red"]
              
              acid_holder[color = "green"]

              mol_start_place -> filter_transition ->
              mol_temp_place  -> bind_transition ->
              mol_end_place [color =red];

              DNA_start_place -> filter_transition -> DNA_end_place
              [color = "blue"];
              acid_holder -> bind_transition [color = "green"];
              
      }
#+END_SRC

    #+RESULTS:
    [[file:ribosome_detailed.png]]

    
**** Modèle 1

*** Bacterie
    Une bacterie contient des molécules. Pour chaque molecule, on 
    connait le nombre présent, et on simule une unique forme protéinée 
    pour toutes les molécules du même type.
****** Note : on pourrait imaginer d'autres formes d'interprétation :
      + fonction (par ex log) du nombre de mols
       + ou autre.

      La simulation est alors découpée en (pour l'instant) deux étapes :
       + Simulation des protéines
       + Résolution des catch/bind

**** Simulation des protéines

   La protéine associée à chaque molécule lance un certain nombre
   de transitions de son réseau de pétri. Pour choisir ce nombre,
   on pourrait :
    + le faire correspondre au nombre de mol présentes
    (ou une fonction de celui-ci
    + Prendre le pgcd de tous les nombres de molécules
    (ou même diviser par le plus petit et arrondir)
    pour que le coût de simulation ne dépende pas du 
    nombre de molécules).

**** Résolution des catch/bind

     On calcule combien de bind sont effectués.

     Pour le déroulé du bind en lui même, on peut aussi avoir
     plusieurs choix :
       + Le bind crée un token
       + Le bind peut seulement se dérouler si un token vide
       se trouve sur la place avec le catcher
       + Si un token occupé par une molécule se trouve sur la
       place, la molécule est remplacée, ou alors une des deux 
       au hasard.


****** Note : du coup pour le simulateur
       On calcule les catch/bind, puis
       on attribue à chaque molécule un certain
       nb de transitions. On peut alors soit
       observer les transitions de chaque molécule,
       soit tout exécuter, etc.

*** Le monde

    Quelques idées : 
 + les bactéries peuvent se duppliquer sans restriction physique.
   À chaque nouvelle bactérie créée on attribue une certaines
   distribution des différentes ressources (acides aminés ?)
 + Matrice (tridimensionnelle), avec des « commandes » pour 
   interagir avec les cellules voisines, se déplacer,
   communiquer, etc..
 + Hôtes pour simuler un comportement multicellulaire : 
   l'hôte a différents emplacements pour cellules, où 
   se trouvent  des recepteurs particuliers, qui permettent
   à l'hôte d'effectuer des actions dans un autre monde physique.
 + Graphe (lazy ?) ou les nœuds contiennent pour chaque arc une 
   interface permettant de simuler une membrane. On peut imaginer
   différentes interfaces, avec différents niveaux de « difficulté ».

*** Énergie
    Les tokens peuvent être un bon moyen de gérer les échanges 
    énergétiques. Le mieux serait sans-doute de faire comme en vrai, 
    c'est à dire qu'établir un liaison coûte de l'énergie, qui est 
    libérée lorsque la liaison est rompue. Ça implique de modifier un 
    peu le condition de grab et de catch/bind, mais ça devrait se faire 
    pas trop difficilement.
    On peut aussi penser à faire des transferts d'énergie entre une 
    protéine et la molécule grabée.
*** Dans un futur lointain

    Pour que les bactéries puissent avoir un comportement efficace, il 
    faudrait qu'il y ait de l'information ambiante, qui représente 
    plusieurs aspects du monde alentour, que les bactéries puissent 
    mesurer

    Implémenter un système similaire à tierra, où les bactéries qui 
    font des actions « interdites » reçoivent un malus, et finissent
    par mourir ?
    (par exemple : problème de transition, problème lors du décalage
    d'une molécule à l'intérieur d'

*** Interface
    
**** Présentation
     On est parti pour faire une interface web uniquement,
     c'est beaucoup plus puissant et quand même plus pratique,
     même si il faut se tapper la couche http.
     
     L'interface est séparée en deux parties : 
     + d'un coté, un simulation (qui contient pour l'instant 
       une bactérie (et plus tard le monde entier))
     + de l'autre coté, un bac à sable qui peut contenir des pnet 
       (qui n'interagissent pas entre eux), et peut-être plus
       tard des bactéries entières.
       

     Pour l'instant, l'interface est centrée sur une unique 
     bactérie.
    
    
    
**** Buts de l'interface :
      + Controler le déroulé de la simulation d'une bactérie :
	- contrôler et afficher chaque pnet individuellement
	- lancer les transitions des pnet de manière globale
	- lancer les interactions entre pnet. 

      + Permettre de tester les pnet en dehors d'une bactérie :
	- Faire des tests de simulation. À partir d'une molécule :
	  * afficher la protéine, le pnet correspondant
	  * afficher et simuler le pnet correspondant. Le pnet
	    est initialisé à l'état initial, et on peut modifier 
	    les tokens à volonté, et lancer les transitions possibles.
	- Faire des tests de création de molécule. Il faut donc une
	  interface qui permette de rentrer la chaîne d'une molécule
	  et d'afficher la protéine et le pnet correspondant, mais aussi
	  de construire directement une protéine

**** Organisation de l'interface

     L'interface sera donc séparée en deux partie : 
      - une partie qui contient la simulation.
	Particularités : dans une bactérie, chaque type 
	de molécule ne possède qu'une unique instance de pnet.
	On peut donc se référer à un pnet en passant 
	la description de la molécule qui l'a généré.
	
	Cette partie contient des commandes qui permettent de 
        contrôler la simulation (transitions de tous les pnet, 
        réactions, etc).


      - une partie bac à sable.
	Particularités : soit chaque molécule 
	n'a qu'une instance de pnet, auquel cas on fait 
	comme dans une bactérie.
	Sinon, il faut que chaque molécule ait en 
	plus un identifiant unique.
	
	Cette partie contient un éditeur de molécule/protéine.
      
     Les deux parties auront un jeu de commandes communes :
      - examen et édition d'un pnet (puis d'une bactérie, etc)

**** Communication serveur/interface

     On aura donc besoin des fonctions suivantes : 
     
      + Fonctions communes à la simulation et au bac à sable :
	- prot_from_mol : renvoie la description d'une protéine 
	  à partir d'une molécule
     
	- pnet_from_mol : renvoie la description du pnet
	  qui correspond à la molécule donnée.
	  Il faut aussi toutes les actions qui permettent de simuler 
	  et tester ce pnet :
	  * Pnet_add_token(pnet_id, place, token)
	  * Pnet_launch_transition (pnet_id, trans_id)
	  * Pnet_remove_token(pnet_id, place)

	- update_bact/mol : envoie la description de l'object demandé
	  (après modification par action du client).
	  
	  
      + Fonctions de la simulation :
	- eval_reactions : reactions entre pnet
	- transitions_round : effectue un round de transitions
	  de tous les pnet

      + Fonctions du bac à sable : 
	- mol_from_prot : pour créer de nouvelles protéines 
	  directement
	- save/load : sauvegarde de molécules sur le système de 
	  fichiers local -> du coup pas fonction serveur 
	  (ou le serveur ?)
     

* Stuff to do
  
** DONE v0.0.0
*** DONE ajouter des arcs entre tous les nœuds dans le client ?
*** DONE Clarifier les dénominations, en particulier input et output links
*** DONE Bugs quand le client demande une transition et que ce n'est pas possible
    

** v0.0.1
*** DONE reconstruire les types d'acides
*** TODO définir et utiliser une convention de nommage qui sépare clairement les noms de types/noms de variables/noms de modules
*** TODO mettre le protocole de communication dans un fichier de configuration lu à la fois par le client et le serveur
*** TODO améliorer le protocole pour unifier les fonctions qui génèrent des données

* In-progress

** TODO fonction make_reactions de l'interface : 
  + evaluer les reactions
  + retourner les données pertinentes
